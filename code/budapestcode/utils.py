"""Module containing utils"""
from numpy.polynomial.legendre import Legendre
import numpy as np
import scipy.linalg as la


def compute_tsnr(data, confounds):
    """Compute tSNR on data by first regressing out the first 10 compcor
    components, framewise displacement, and high-pass filtering the data.

    Parameters
    ----------
    data : array of shape (dim1, dim2, dim3, n_volumes)
        EPI data
    confounds : pandas Dataframe
        dataframe containing confounds generated by fmriprepp
    
    Returns
    ------
    tsnr : array of shape (dim1, dim2, dim3)
        temporal SNR array
    """
    # reshape
    data = data.T
    orig_shape = data.shape
    data = data.reshape(orig_shape[0], -1)
    # store mean
    data_mean = data.mean(0)
    data_clean = clean_data(data, confounds)
    # compute std
    std = data_clean.std(0)
    std[std < 1e-8] = 1
    tsnr = data_mean / std
    # reshape to the original shape
    tsnr = tsnr.reshape(orig_shape[1:]).T
    return tsnr


def clean_data(data, confounds):
    """Clean data by regressing out the first 10 compcor
    components, framewise displacement, and high-pass filtering the data

    Parameters
    ----------
    data : array of shape (n_volumes, n_features)
        flattened EPI data
    confounds : pandas Dataframe
        dataframe containing confounds generated by fmriprepp

    Returns
    -------
    data_clean : array of shape (n_volumes, n_features)
        denoised data
    """
    # make predictor matrix using confounds computed by fmriprep
    columns = [
        'framewise_displacement'
    ]
    # compcor
    n_comp_cor = 10
    columns += [f"a_comp_cor_{c:02d}" for c in range(n_comp_cor)]
    # high-pass filtering
    columns += [col for col in confounds.columns if 'cosine' in col]

    X = confounds[columns].values
    # remove nans
    X[np.isnan(X)] = 0.

    # time to clean up
    # center the data first and store the mean
    data_mean = data.mean(0)
    data = data - data_mean
    coef, _, _, _ = la.lstsq(X, data)
    # remove trends and add back mean of the data
    data_clean = data - X.dot(coef) + data_mean
    return data_clean
